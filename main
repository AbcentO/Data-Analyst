Задание 1

# Подход с условной вероятностью
colvoGoodProject = 0
allProject = 200
probSuccessProject = colvoGoodProject / allProject
print("Вероятность успешного прототипа для нашей компании (подход с условной вероятностью):", probSuccessProject)

# Байесовский подход
colvoGoodProjectKonkurent = 5
allProjectKonkurent = 1000
apriorProbSuccessProject = colvoGoodProjectKonkurent / allProjectKonkurent
aposterProbSuccessProject = (colvoGoodProject + colvoGoodProjectKonkurent) / (allProject + allProjectKonkurent)
print("Вероятность успешного прототипа для нашей компании (байесовский подход):", aposterProbSuccessProject)

Задание 2
1. Оптимальный дизайн эксперимента:
   - Разделите игроков на две группы: контрольную (без изменений) и экспериментальную (с обновлением).
   - Случайным образом выберите игроков для каждой группы, чтобы избежать искажений.
   - Запустите обновление только для экспериментальной группы.
   - Соберите данные о платежах от обеих групп в течение определенного периода времени.

2. Расчет длительности эксперимента:
   - При условии, что каждый день в игру приходит около 100 новых игроков, мы можем рассчитать, сколько дней потребуется для набора достаточного количества данных. Нам нужно убедиться, что у нас будет достаточно наблюдений для обеих групп, чтобы сделать статистически значимые выводы.

3. Генерация контрольной группы и расчет доверительного интервала:
   - Создадим случайный набор данных, где около 10% игроков совершают платежи.
   - Рассчитаем доверительный интервал для этой группы, чтобы оценить диапазон значений, в котором с определенной вероятностью находится истинное значение доли плательщиков.

4. Генерация экспериментальных групп и расчет силы эффекта:
   - Создадим несколько вариантов экспериментальных групп, отражающих худший, лучший и нейтральный эффект обновления.
   - Рассчитаем силу эффекта для каждой группы, чтобы определить, насколько значимы изменения в проценте плательщиков.
   - Сравним результаты с контрольной группой и сделаем выводы о влиянии обновления.

5. Решение задачи двумя подходами:
   - Для frequentist подхода используем классические статистические методы, такие как доверительные интервалы и тесты на значимость.
   - Для bayesian подхода используем байесовские методы, которые позволяют учитывать априорные знания и обновлять их на основе новых данных.

import numpy as np
from statsmodels.stats.proportion import proportion_confint
import pymc3 as pm

# Генерация данных для контрольной группы (500 игроков)
np.random.seed(0)  # Зафиксируем seed для воспроизводимости результатов
control_group = np.random.choice([0, 1], size=500, p=[0.9, 0.1])  # 10% игроков совершают платежи

# Расчет доверительного интервала для доли плательщиков в контрольной группе
ci = proportion_confint(sum(control_group), len(control_group), method='wilson')
print("Доверительный интервал для доли плательщиков в контрольной группе:", ci)
import statsmodels.api as sm

# Генерация данных для экспериментальной группы (с различными вариантами эффекта)
# Предположим, что у нас есть три варианта: худший, лучший и нейтральный эффект
experimental_group_worst = np.random.choice([0, 1], size=500, p=[0.95, 0.05])  # Худший эффект (5% плательщиков)
experimental_group_best = np.random.choice([0, 1], size=500, p=[0.88, 0.12])  # Лучший эффект (12% плательщиков)
experimental_group_neutral = np.random.choice([0, 1], size=500, p=[0.9, 0.1])  # Нейтральный эффект (10% плательщиков)

# Расчет силы эффекта для каждой экспериментальной группы
effect_size_worst = sm.stats.proportion_effectsize(sum(experimental_group_worst), len(experimental_group_worst))
effect_size_best = sm.stats.proportion_effectsize(sum(experimental_group_best), len(experimental_group_best))
effect_size_neutral = sm.stats.proportion_effectsize(sum(experimental_group_neutral), len(experimental_group_neutral))

print("Сила эффекта для худшего варианта:", effect_size_worst)
print("Сила эффекта для лучшего варианта:", effect_size_best)
print("Сила эффекта для нейтрального варианта:", effect_size_neutral)
from statsmodels.stats.proportion import proportions_ztest

# Пример проведения Z-теста между контрольной и экспериментальной группой с лучшим вариантом эффекта
count = np.array([sum(control_group), sum(experimental_group_best)])
nobs = np.array([len(control_group), len(experimental_group_best)])
z_stat, p_value = proportions_ztest(count, nobs)
print("Z-статистика:", z_stat)
print("p-значение:", p_value)

# Определение байесовской модели для оценки вероятностей различных вариантов эффекта
with pm.Model() as model:
    # Априорное распределение для доли плательщиков в экспериментальной группе с лучшим вариантом эффекта
    p = pm.Beta('p', alpha=1, beta=1)
    
    # Наблюдаемые данные
    obs = pm.Bernoulli('obs', p, observed=experimental_group_best)
    
    # Выполнение байесовской оценки
    trace = pm.sample(1000, tune=1000)

# Визуализация результатов
pm.plot_posterior(trace)
Для работоспособности кода необходимо установить модуль pymc3

Задание 3
Для решения задачи предсказания отвала игрока можно воспользоваться методами машинного обучения, такими как классификация. В данном случае можно использовать исторические данные о прохождении туториала для обучения модели.

1. Можно использовать такие алгоритмы машинного обучения, такие как случайный лес, градиентный бустинг или нейронные сети, 
чтобы предсказать вероятность отвала игрока на каждом шаге туториала.

2. Для оценки качества модели можно воспользоваться различными метриками, 
такими как точность, полнота, F1-мера и ROC-кривая. Оптимальной метрикой зависит от конкретной задачи и бизнес-целей. 
Например, если важно минимизировать ложноположительные предсказания (когда модель предсказывает отвал там, где его на самом деле нет), 
то можно использовать метрику precision. Если важно минимизировать ложноотрицательные предсказания (когда модель не предсказывает отвал там, где он есть), 
то можно использовать метрику recall.

3. Для проверки гипотезы геймдизайнеров можно провести A/B-тестирование. Например, можно случайным образом разделить игроков на две группы: одной группе показывать стандартное продолжение туториала, а другой - альтернативное продолжение, основанное на предсказаниях модели. Затем можно сравнить отток игроков из каждой группы, чтобы определить, действительно ли альтернативное продолжение туториала уменьшает отток.
